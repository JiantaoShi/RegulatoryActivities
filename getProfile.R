# args = list()
# args$windowFile = 'hg19_windows.bed'
# args$signalFile = 'debug_score.tsv'
# args$outTag = 'ff'
# args$BED = 'esophagus_LMRs.bed'

library("optparse")

option_list = list(make_option("--windowFile", type = "character", default = NULL, help  = "Window file returned by makeWindows."),
				   make_option("--signalFile", type = "character", default = NULL, help = "Signal file generated by deepTools on regions defined in window_file."),
				   make_option("--BED", type = "character", default = NULL, help = "BED file of interest."),
				   make_option("--method", type = "character", default = 'mean', help = "Summary method [mean, median]."),
				   make_option("--outTag", type = "character", default = NULL, help = "Prefix for output files."))		   
args <- parse_args(OptionParser(option_list=option_list))

# check parameters
if(is.null(args$windowFile))
	stop("\nArgument windowFile is required.\n")
if(is.null(args$signalFile))
	stop("Argument signalFile is required.\n")
if(is.null(args$outTag))
	stop("Argument outTag is required.\n")

# load required libraries
library("GenomicRanges")

# read window and signal file
tr = read.table(file = args$windowFile, row.names = NULL, header = FALSE, comment.char = "#")
ts = read.table(file = args$signalFile, row.names = NULL, header = FALSE, comment.char = "#")
gr = GRanges(seqnames = as.character(tr[,1]), 
			ranges = IRanges(start = as.numeric(tr[,2]), end = as.numeric(tr[,3])),
			name = as.character(tr[,4]))
gs = GRanges(seqnames = as.character(ts[,1]), 
			ranges = IRanges(start = as.numeric(ts[,2]), end = as.numeric(ts[,3])),
			score = as.numeric(ts[,4]))

# after sorting, two GRanges should order in the same way
gr = sort(gr)
gs = sort(gs)
gr$score = gs$score

# update gene_id, gene_name, window
chunks = strsplit(gr$name, "_")
gr$gene_id = sapply(chunks, function(z) z[1])
gr$gene_name = sapply(chunks, function(z) z[2])
gr$window = sapply(chunks, function(z) paste0(z[3], '_', z[4]))
gr = gr[!is.na(gr$score)]

# summary golbal
wid = unique(gr$window)
outAll = matrix(NA,  nrow = length(wid), ncol = 2, dimnames = list(wid, c('Num_All', 'Score_All')))

tmp = aggregate(rep(1, length(gr)), by = list(factor(gr$window)), FUN = 'sum')
rownames(tmp) = as.character(tmp[,1])
outAll[,1] = tmp[wid, 2]

tmp = aggregate(gr$score, by = list(factor(gr$window)), FUN = args$method)
rownames(tmp) = as.character(tmp[,1])
outAll[,2] = tmp[wid, 2]

if(is.null(args$BED)){
	write.table(outAll, file = paste0(args$outTag, '_profile.tsv'), row.names = TRUE, col.names = TRUE, sep = '\t', quote = FALSE)
} else {
	tb = read.table(file = args$BED, row.names = NULL, header = FALSE, comment.char = "#")
	gb = GRanges(seqnames = as.character(tb[,1]), ranges = IRanges(start = as.numeric(tb[,2]), end = as.numeric(tb[,3])))
	gr$Feature = countOverlaps(gr, gb, type = 'any', ignore.strand = TRUE) > 0
	gx = gr[gr$Feature]

	outFeature = matrix(NA,  nrow = length(wid), ncol = 2, dimnames = list(wid, c('Num_Feature', 'Score_Feature')))
	tmp = aggregate(rep(1, length(gx)), by = list(factor(gx$window)), FUN = 'sum')
	rownames(tmp) = as.character(tmp[,1])
	outFeature[rownames(tmp),1] = tmp[, 2]

	tmp = aggregate(gx$score, by = list(factor(gx$window)), FUN = args$method)
	rownames(tmp) = as.character(tmp[,1])
	outFeature[rownames(tmp),2] = tmp[, 2]

	out = cbind(outAll, outFeature)
	write.table(out, file = paste0(args$outTag, '_profile.tsv'), row.names = TRUE, col.names = TRUE, sep = '\t', quote = FALSE)
}
